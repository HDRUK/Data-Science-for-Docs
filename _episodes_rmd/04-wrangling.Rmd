---
source: Rmd
title: "Data Wrangling"
teaching: 10
exercises: 2
questions:
- "---?"
objectives:
- "---."
- "---."
keypoints:
- "---"
- "----"
---
## Learning Objectives

By the end of this session, you should be able to:
- Use the **tidyverse** package to build your first data pipeline.
- [Import the data to R](#readr)
- [Manipulate and clean the data](#dplyr)

## Lesson

<a name="readr"></a>

### Import Data

For the purposes of ESICM, we have already included data in your RStudio instance. To import this into R, we simply need to run a function and that read the csv files.

```{r, include = FALSE}
# library(tidyverse)
# long_df <- read_csv("~/_data/esicm/longitudinal-data.csv")
# demo_df <- read_csv("~/_data/esicm/demographic-data.csv")
```

```{r, eval = FALSE}
# library(tidyverse)
# long_df <- read_csv("./data/longitudinal-data.csv")
# demo_df <- read_csv("./data/demographic-data.csv")
```

We have largely done the hard work for you in creating these tables, so that they are already close to what is considered a "tidy" format. Tidy data means:
- Each column is a variable.
- Each row is an observation.

There is more information on what constitutes tidy data at [r4ds](https://r4ds.had.co.nz/tidy-data.html). There are still a few things left to change, and we will adress these now.

before doing anything else, let's examine our data. If you simply type the data frame name into the console, it will print a truncated view of the data.

```{r}
# long_df
# demo_df
```

Another very powerful way to view the data is to use the `glimpse` function

```{r}
# glimpse(long_df)
# glimpse(demo_df)
```

Here you get to see all the variable names within the data frame, what data type is being used, and the first few values (as many as can fit on the screen).

<a name="dplyr"></a>

### Data wrangling with dplyr

The `dplyr` package provides useful _grammar_ for simplifying data manipulation. It is not needed but makes manipulation verbose and intuitive and is highly recommended.

First, let's _filter_ the demographic data by row

```{r}
# filter(demo_df, height >= 180)
```

This _filters_ rows from the `demo_df` data frame where `height` is greater than or equal to `180`cm.

> **TIP:** Comparisons in R: Most of these are obvious `>` (greater than), `>=` (greater than or equal to), and similarly for `<` and `<=`.  The `!=` operator means 'not equal to'. But when we want to check if something _is_ equal to something else we _must_ use `==`. Why? Because although R prefers you to use `<-` when you name things, most programming languages use `=`, and even R expects you to use `=` when you pass values to functions. So, for a function such as `mean(x)` we are normally lazy when we write `mean(hrate)`. We should write `mean(x=hrate)`, because _inside_ the function all the work is done with the variable `x`. When we write `mean(x=hrate)` we explicitly telling R that we want it to use `hrate` in place of `x`. This is a very long winded way of saying that when you want to _test_ if one thing is equal to another then you need a different way of writing this, hence `==`.

Filter **always** acts on rows, and will throw away any data that doesn't meet your request.

A similar function called `select` acts over columns. Just want the `sex` colum?

```{r}
# select(demo_df, sex)
```

So `filter` chooses rows, and `select` chooses columns.

Now here comes the _proper_ magic. What if you want to both filter and select?

```{r}
# demo_df %>%
#   filter(height >= 180) %>%
#   select(sex)
```

The `%>%` operator is called a **pipe**, and it (surprise, surprise) _pipes_ data from one command to the next. So in plain English, the above line takes the data frame `demo_df` and pipes it into the _filter_ function, removing all patients under `65`. It then pipes the filtered data into the `select` function where only the `sex` column is retained.

The benefit of writing code like this, is that you start with your data at the top, and then each line is a single function that performs an action. The data is processed one step at a time at the bottom you get your tidy data. This is the very start of a data pipeline.

> **TIP:** The order matters in a pipe! If we were to use the `select` function first, then the `filter` function would not have a `height` column to filter on.).

Next, you can continue to expand your data pipeline by piping your data into another function. We might want to summarise the data. By appending the pipeline with the `table` function we can tabulate the results.

```{r}
# Summarise
# demo_df %>%
#   filter(height >= 180) %>%
#   select(sex) %>%
#   table()
```

There are a small number of 'verbs' (functions) in the dplyr package that when combined allow you to complete a large number of useful data maniputations. In addition to `select`, and `filter`, you will want you to learn:

1. `arrange` - orders data using a named column
2. `group_by`- sets a column to be a grouping variable
3. `summarise`- summarises data over a grouping variable
4. `mutate` - add a new column to the data

Armed with only these 6 functions, you can accomplish a huge amount that would be tiresome and frustrating in excel.

```{r}
# demo_df %>%
#   select(height, weight, sex) %>%
#   arrange(height)
```

Here we see an example where we select the height, weight and sex columns, and then arrange the data by the height column.

```{r}
# demo_df %>%
#   group_by(sex) %>%
#   summarise(average_height = mean(height, na.rm = TRUE))
```

We now see an example of `group_by` and `summarise` being used together. The result is to apply the function `mean` to each group, and summarise the results. The `na.rm = TRUE` has to be added, as missing values are present in the data, and mean will otherwise not work.

We might be interested in computing the BMI for a patient. We can do this easily by adding a new column with the `mutate` verb.

```{r}
# demo_df %>%
#   mutate(bmi = weight / (height/100)^2) %>%
#   select(weight, height, bmi) %>%
#   arrange(desc(bmi))
```

We now create a new column called `bmi` and then present this data, ordered in reverse (so the biggest is now at the top)

## Data Cleaning

We will now go through some common data cleaning tasks. It is better to try and do these in R, rather than ajust the underlying data in excel if possible. Some tasks are going to have to be done in excel, but the more you can do this with written instructions (and hence have written documentation) the better.

```{r}
# names(demo_df)
```

It looks like the `discharge` variable is a little ambiguously named. Let's change that so it is clear.

```{r}
# demo_df <- demo_df %>%
#   rename(discharge_dttm = discharge)
```

We're using the `rename` function from the dplyr package, and then 'overwriting' our existing data with the renamed data.

<a name="stringr"></a>

#### Wrangling strings

#### Recipe 2: Extract numbers

If we look at the primary_adm column, we see that it is stored as a string. This is the first two codes from the ICNARC classification codes for a primary diagnosis. In reality, it is probably more use to split this code apart, and create a new column for each. We can do this with two functions from the tidyverse: `separate` and `extract_numeric`.

```{r}
# demo_df <- demo_df %>%
#   separate(col = primary_adm, into = c("pt_type", "organ_system"), sep = "\\.", remove = FALSE)
# 
# demo_df <- demo_df %>%
#   mutate(pt_type = extract_numeric(pt_type)) %>%
#   mutate(organ_system = extract_numeric(organ_system))
```

Now lets view the result

```{r}
# demo_df %>%
#   select(primary_adm, pt_type, organ_system)
```

#### Recipe 4: Parsing dates

Let's create two new columns that show us the length of stay for a patient, and their age on admission.

Dates can be extremely fiddly, but fortunately, tidyverse comes to our rescue. We will need only the `dob` and `discharge_dttm` columns to do what we want. Note that all these patients are admitted on 1st Jan 2000.

```{r}
# demo_df %>%
#   select(dob, discharge_dttm) %>%
#   glimpse()
```

```{r}
# library(lubridate)
# all_admissions <- ymd_hms("2000-01-01 00:00:00")
# 
# demo_df <- demo_df %>%
#   mutate(age = interval(dob, all_admissions) / years(1)) %>%
#   mutate(los = interval(all_admissions, discharge_dttm) / days(1))
# 
# demo_df %>%
#   select(age, los)
```

<a name="tidyr"></a>

## Exercises

Have a look at the help files for the following common functions, and see if you can work out how they work. Do you need to use some of these with your data to clean it?

### Strings

- `str_to_lower`
- `str_split`
- `str_detect`

### Dates and Times

- parsing (reading) dates:
  - `ymd()`
  - `dmy()`
  - `mdy_hm()`, etc
- extracting components:
  - `second()`
  - `minute()`
  - `day()`
  
